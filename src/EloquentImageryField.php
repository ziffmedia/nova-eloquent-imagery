<?php

namespace ZiffMedia\NovaEloquentImagery;

use Illuminate\Support\Collection;
use Illuminate\Support\Str;
use Laravel\Nova\Fields\Field;
use Laravel\Nova\Http\Requests\NovaRequest;
use ZiffMedia\LaravelEloquentImagery\Eloquent\Image;
use ZiffMedia\LaravelEloquentImagery\Eloquent\ImageCollection;

class EloquentImageryField extends Field
{
    public $component = 'eloquent-imagery';

    public $showOnIndex = false;

    protected $metadataFormConfiguration = [];

    protected $thumbnailUrlModifiers;

    protected $previewUrlModifiers;

    protected function fillAttribute(NovaRequest $request, $requestAttribute, $model, $attribute)
    {
        if (! $request->exists($requestAttribute)) {
            return;
        }

        $value = json_decode($request[$requestAttribute], true);

        /** @var Image|ImageCollection $fieldAttribute */
        $fieldAttribute = $model->{$attribute};

        if (! $fieldAttribute instanceof Image && ! $fieldAttribute instanceof ImageCollection) {
            throw new \RuntimeException('Field must be an EloquentImagery field');
        }

        ($fieldAttribute instanceof ImageCollection)
            ? $this->resolveImageCollectionFromFormData($value, $fieldAttribute)
            : $this->resolveImageFromFormData($value, $fieldAttribute);

        $fieldAttribute->updatePath([], $model);
    }

    public function withMetadataFormConfiguration(array $metadataFormConfiguration)
    {
        $this->metadataFormConfiguration = $metadataFormConfiguration;

        return $this;
    }

    public function meta()
    {
        $meta = $this->meta;

        if ($this->value instanceof ImageCollection) {
            $isCollection = true;

            $value = [
                'autoincrement' => $this->value->getAutoincrement(),
                'images'        => [],
            ];

            foreach ($this->value as $image) {
                $value['images'][] = $this->convertImageToResourceValue($image);
            }
        } else {
            $isCollection = false;

            $value = ($this->value->exists()) ? $this->convertImageToResourceValue($this->value) : null;
        }

        return array_merge($meta, [
            'value' => $value,
            'isCollection' => $isCollection,
            'metadataFormConfiguration' => collect(['fields' => [], 'allowAddMetadata' => true, 'preserveExistingMetadata' => true])
                ->merge($this->metadataFormConfiguration)
                ->mapWithKeys(fn ($value, $key) => [Str::camel($key) => $value])
                ->toArray(),
        ]);
    }

    public function jsonSerialize(): array
    {
        return parent::jsonSerialize(); // TODO: Change the autogenerated stub
    }

    protected function convertImageToResourceValue(Image $image): array
    {
        return [
            'previewUrl' => $image->url(
                ($this->previewUrlModifiers ? $this->previewUrlModifiers . '|' : '')
                . 'v' . $image->timestamp
            ),
            'thumbnailUrl' => $image->url(
                ($this->thumbnailUrlModifiers ? $this->thumbnailUrlModifiers . '|' : '')
                . 'v' . $image->timestamp
            ),
            'path'     => $image->path,
            'metadata' => $image->metadata,
        ];
    }

    /**
     * @param $previewUrlModifiers
     * @return $this
     */
    public function previewUrlModifiers($previewUrlModifiers): static
    {
        $this->previewUrlModifiers = $previewUrlModifiers;

        return $this;
    }

    /**
     * @param $thumbnailUrlModifiers
     * @return $this
     */
    public function thumbnailUrlModifiers($thumbnailUrlModifiers): static
    {
        $this->thumbnailUrlModifiers = $thumbnailUrlModifiers;

        return $this;
    }

    protected function resolveImageFromFormData($formData, Image $image): void
    {
        if ($formData === null) {
            if ($image->exists()) {
                $image->remove();
            }

            return;
        }

        if (isset($formData['fileData'])) {
            $image->setData($formData['fileData']);
        }

        $image->metadata = new Collection($formData['metadata'] ?? []);
    }

    protected function resolveImageCollectionFromFormData(array $formData, ImageCollection $imageCollection): void
    {
        // create a collection of mapped path=>image of the existing images
        $existingImages = $imageCollection->mapWithKeys(function ($image, $index) {
            return [$image->path => ['image' => $image, 'original_index' => $index]];
        });

        $newCollectionForImages = new Collection;

        // iterate over provided value from form, start creating an array of images for the new ImageCollection
        foreach ($formData as $imageIndex => $imageData) {
            if ($imageData['path']) {
                $image = $existingImages[$imageData['path']]['image'];
                unset($existingImages[$imageData['path']]);
            } else {
                $image = $imageCollection->createImage($imageData['fileData']);
            }

            // if bytes were provided, set them
            if (isset($imageData['fileData'])) {
                $image->setData($imageData['fileData']);
            }

            // store the metadata
            $image->metadata = new Collection($imageData['metadata']);

            $newCollectionForImages[$imageIndex] = $image;
        }

        // what is left over needs to be removed from the original attribute
        foreach ($existingImages as $leftOverImages) {
            unset($imageCollection[$leftOverImages['original_index']]);
        }

        // finally replace the image collection's interal/wrapped collection
        $imageCollection->replaceWrappedCollectionForImages($newCollectionForImages);
    }

    public function resolveDependentValue(NovaRequest $request)
    {
        if ($this->value instanceof ImageCollection) {
            return [
                'autoincrement' => $this->value->getAutoincrement(),
                'images'        => $this->value->map(fn (Image $image) => $this->convertImageToResourceValue($image))->toArray(),
            ];
        }


        return $this->value->exists() ? $this->convertImageToResourceValue($this->value) : null;

    }
}
